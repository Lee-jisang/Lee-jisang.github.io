---
title: 우선순위 큐(Priority Queue)와 힙(Heap)
categories: 
  - Data Structure
excerpt: 우선순위 큐와 힙에 대해 알아보자.
date: 2022-05-15
tags: 
- heap
- priority queue

---



> # 우선순위 큐(Priority Queue)
---

## 개념

큐(Queue)는 먼저 들어오는 데이터가 먼저 나가는 FIFO(First In First Out) 형식의 자료구조이다.
우선순위 큐(Priority Queue)는 먼저 들어오는 데이터가 아니라, **우선순위가 높은 데이터**가 먼저 나가는 형태의 자료구조이다.

우선순위 큐는 일반적으로 **힙(Heap)** 을 이용하여 구현한다.


<br />


## 우선순위 큐를 힙으로 구현하는 이유 

(1) 만일 배열로 구현한다고 가정합니다. 우선순위가 높은 순서대로 배열의 가장 앞부분부터 넣는다면, 우선순위가 높은 데이터를 반환하는 것은 맨 앞의 인덱스를 바로 이용하면 되므로 어렵지 않습니다.

하지만 우선순위가 중간인 것이 들어가야 하는 삽입 과정에서는 뒤의 데이터까지 인덱스를 모두 한 칸씩 뒤로 밀어야 하는 단점이 있습니다.

최악의 경우 삽입해야 하는 위치를 찾기 위해 모든 인덱스를 탐색해야 합니다. 즉 이 때의 시간 복잡도는 자료가 n개라고 할 때 O(n) 이 됩니다. → 배열로 구현 시 시간 복잡도 : 삭제는 O(1), 삽입은 O(n)

<hr>

(2) 만일 연결리스트로 구현한다고 가정합니다. 이 또한 우선 순위가 높은 순서대로 연결을 시키면, 우선순위가 높은 데이터의 반환은 배열과 마찬가지로 쉽습니다.

하지만 연결리스트 또한 삽입의 과정 또한 배열과 마찬가지로 그 위치를 찾아야 합니다. 최악의 경우 맨 끝에까지 가게 됩니다. → 연결리스트로 구현 시 시간 복잡도 : 삭제는 O(1), 삽입은 O(n)

<hr>

(3) 우선순위 큐를 힙으로 구현한다고 가정합니다. 힙의 경우 삭제나 삽입 과정에서 모두 부모와 자식 간의 비교만 계속 이루어집니다. (아래에서 다룰 것입니다)

즉, 이진 트리의 높이가 하나 증가할 때마다 저장 가능한 자료의 갯수는 2배 증가하며, 비교 연산 횟수는 1회 증가합니다. 즉 삭제나 삽입 모두 최악의 경우에는 O(log2n) 의 시간 복잡도를 가집니다. → 힙으로 구현 시 시간 복잡도 : 삭제는 O(log2n), 삽입은 O(log2n)

이처럼 배열이나 연결 리스트가 삭제에서는 시간 복잡도의 우위를 점할지라도, 삽입의 시간 복잡도가 힙 기반이 월등하기 때문에, 편차가 심한 배열과 연결리스트보다는 힙으로 구현하는 것입니다.

<br />




> # 힙(Heap)
---

## 개념


힙(Heap)은 우선순위 큐를 위해 고안된 완전이진트리 형태의 자료구조이다.<br>
여러 개의 값 중 최댓값 또는 최솟값을 찾아내는 연산이 빠르다.

<br />


## 특징

- 완전이진트리 형태로 이루어져 있다.
- 부모노드와 서브트리간 대소 관계가 성립된다. (반정렬 상태)
- 이진탐색트리(BST)와 달리 중복된 값이 허용된다.

<br />

## 종류


### 최대 힙(Max Heap)

부모 노드의 키 값이 자식 노드보다 크거나 같은 완전이진트리이다.

![image](https://user-images.githubusercontent.com/76837780/168473673-e93fdbc9-d686-45bb-95e1-0f5e2ac2ac05.png)

<br />


### 최소 힙(Min Heap)

부모 노드의 키 값이 자식 노드보다 작거나 같은 완전이진트리이다.

![image](https://user-images.githubusercontent.com/76837780/168473677-3108799d-d51a-43ec-9855-11a7049a2fbb.png)

<br />


**최대 힙이던 최소 힙이던 루트 노드에는 우선순위가 높은 것이 자리잡게 됩니다.**
